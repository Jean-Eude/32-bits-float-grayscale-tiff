\underset{\text{16 bits}}{\text{PNG}} \longrightarrow \underset{\text{8 bits}}{\text{TIFF}}

\underset{\text{16 bits}}{\text{PNG}} 
\xrightarrow{\text{conversion}} 
\underset{\text{8 bits}}{\text{TIFF}} 
\xrightarrow{\text{conversion}} 
\underset{\text{8 bits}}{\text{JPEG}}


\[
\underset{\text{16 bits}}{\text{PNG}} 
\xrightarrow{\text{conversion}} 
\underset{\text{32 bits (flottant)}}{\text{TIFF}} 
\xrightarrow{\text{conversion}} 
\underset{\text{64 bits (double)}}{\text{JPEG}}
\]



Chapitre 1 â€“ Normalisation des IntensitÃ©s
Objectif :
PrÃ©parer lâ€™image Ã  lâ€™analyse en rÃ©duisant lâ€™influence des valeurs extrÃªmes (pixels trÃ¨s sombres ou saturÃ©s) qui peuvent fausser les traitements statistiques.

Description :
Lâ€™image est dâ€™abord normalisÃ©e selon une mÃ©thode robuste : les intensitÃ©s sont rÃ©ajustÃ©es pour que la valeur au 5e percentile devienne 0 et celle au 95e percentile devienne 1.
Cela signifie que les 5 % des pixels les plus sombres sont tous ramenÃ©s Ã  0, et les 5 % les plus brillants Ã  1.

Fonction utilisÃ©e :
image_normalisee.normalizePercentile(0.05, 0.95);

Cela permet :

    Dâ€™Ã©liminer lâ€™effet des artefacts trÃ¨s lumineux

    De travailler dans une Ã©chelle commune et stable

    Dâ€™amÃ©liorer la prÃ©cision des dÃ©tections locales

Chapitre 2 â€“ DÃ©tection Locale dâ€™Anomalies (Z-Score sur Image NormalisÃ©e)
Objectif :
DÃ©tecter les points brillants anormaux (spikes) qui ressortent fortement de leur voisinage.

MÃ©thode :
Pour chaque pixel de lâ€™image normalisÃ©e, on analyse une fenÃªtre locale (gÃ©nÃ©ralement 5Ã—5 pixels) centrÃ©e autour de lui :

    On calcule la moyenne et lâ€™Ã©cart-type des pixels voisins (sans inclure le pixel central).

    Si le pixel central dÃ©passe significativement cette moyenne (au-delÃ  dâ€™un seuil dynamique k), on le considÃ¨re comme un artefact.

Le seuil k est estimÃ© automatiquement selon la dispersion globale de lâ€™image, typiquement entre 0.7 et 1.25.

Fonctions utilisÃ©es :
double k = estimateK(image_normalisee);
detectZScoreSpikes(image_normalisee, mask_norm, k);

Un masque binaire est gÃ©nÃ©rÃ© oÃ¹ les pixels anormaux sont marquÃ©s avec la valeur 1.

Chapitre 3 â€“ DÃ©tection sur lâ€™Image Brute
Objectif :
RepÃ©rer les artefacts qui ne sont pas visibles aprÃ¨s normalisation, notamment les valeurs extrÃªmes absolues comme les saturations.

Description :
On applique la mÃªme mÃ©thode de Z-score, mais cette fois directement sur lâ€™image originale (non normalisÃ©e). Cela permet de conserver une analyse en valeur absolue.

Fonctions utilisÃ©es :
k = estimateK(image);
detectZScoreSpikes(image, mask_spikes_raw, k);

Pourquoi cette double analyse ?

    Lâ€™image normalisÃ©e permet de dÃ©tecter les anomalies relatives (locales).

    Lâ€™image brute permet de dÃ©tecter les anomalies absolues (globales, saturations).

On gÃ©nÃ¨re ainsi un second masque binaire complÃ©mentaire.

Chapitre 4 â€“ Fusion des Masques
Objectif :
Combiner les diffÃ©rentes dÃ©tections pour crÃ©er un masque global des pixels Ã  corriger.

Description :
On fusionne :

    Le masque des anomalies normalisÃ©es

    Le masque des anomalies brutes

    (Ã‰ventuellement) un masque basÃ© sur le gradient (bords brillants)

Pour chaque pixel, on prend la valeur maximale des trois masques. Si au moins une mÃ©thode dÃ©tecte un dÃ©faut, ce pixel est marquÃ© comme corrompu.

Code utilisÃ© :
double m = std::max({mask_norm.getPixel(x, y), mask_spikes_raw.getPixel(x, y), mask_grad_morpho.getPixel(x, y)});
mask_fusion.setPixel(x, y, m);

RÃ©sultat :
Un masque final mask_fusion indiquant toutes les zones problÃ©matiques de lâ€™image.

Chapitre 5 â€“ Correction Robuste par Interpolation
Objectif :
Remplacer les pixels corrompus par des estimations fiables Ã  partir de leurs voisins non corrompus, tout en prÃ©servant les dÃ©tails et la cohÃ©rence locale.

Description :
Pour chaque pixel Ã  corriger :

    On sÃ©lectionne une grande fenÃªtre autour (typiquement 11Ã—11).

    On ignore les pixels eux-mÃªmes corrompus dans le masque.

    Pour les autres, on calcule une moyenne pondÃ©rÃ©e :

        Les pixels proches comptent plus que les lointains.

        Le poids est dÃ©terminÃ© par une fonction gaussienne :
        w = exp(-distanceÂ² / 2ÏƒÂ²)

Si aucun voisin sain nâ€™est trouvÃ©, on utilise une moyenne brute comme solution de secours.

Chaque pixel corrigÃ© est aussi marquÃ© dans une carte de modifications, ce qui permet dâ€™Ã©valuer la portÃ©e des changements.

Fonction utilisÃ©e :
corrigerImageRobuste(image_normalisee, mask_fusion, image_corrigee, 11, &carte_modifs);

Chapitre 6 â€“ RÃ©sultat et Ã‰valuation
AprÃ¨s la correction, on peut :

    Visualiser lâ€™image corrigÃ©e et la carte des modifications

    Comparer avec lâ€™image dâ€™origine via des mÃ©triques :

        PSNR (Peak Signal-to-Noise Ratio) : mesure quantitative de la fidÃ©litÃ©

        SSIM (Structural Similarity Index) : mesure perceptuelle de la qualitÃ©

Ces mesures permettent de valider objectivement la qualitÃ© de la correction.

Conclusion
Ce pipeline suit une dÃ©marche robuste et progressive :

    PrÃ©traitement fiable par normalisation

    DÃ©tections locales et globales des dÃ©fauts

    Fusion intelligente des rÃ©sultats

    Interpolation douce et localisÃ©e

Il est particuliÃ¨rement adaptÃ© au traitement dâ€™images scientifiques ou Ã  haute dynamique, oÃ¹ les artefacts lumineux et saturÃ©s sont frÃ©quents.




ğŸ” DÃ©tails des types de relations reprÃ©sentÃ©es :

    HÃ©ritage (Traitements â†’ Parser)

        ReprÃ©sentÃ© par une flÃ¨che vide (â—)

        Traitements hÃ©rite de Parser, donc il rÃ©cupÃ¨re ses attributs/mÃ©thodes

    DÃ©pendance / Utilisation (Traitements -- TiFF, Traitements -- Filesystem)

        ReprÃ©sentÃ© par une flÃ¨che en pointillÃ© (---â–·)

        Traitements utilise les mÃ©thodes ou types dÃ©clarÃ©s dans ces classes, sans en Ãªtre propriÃ©taire

ğŸ“˜ Rappel des types de relations possibles en UML :
Type de relation	Symbole	Description
Association	â€”	Lien logique entre deux classes (ex. une classe a une autre en attribut)
AgrÃ©gation	â—‡â€”	Relation â€œa unâ€, mais sans possession stricte (ex. collection)
Composition	â—†â€”	Lien fort, cycle de vie dÃ©pendant (ex. partie-tout)
HÃ©ritage	â—	Classe fille hÃ©rite dâ€™une classe mÃ¨re
RÃ©alisation (interface)	â—â•Œ	ImplÃ©mentation dâ€™une interface
DÃ©pendance	--â–· (pointillÃ©e)	Utilisation temporaire dâ€™une classe (paramÃ¨tre, appel)










