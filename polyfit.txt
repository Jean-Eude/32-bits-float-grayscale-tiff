âœ… Fonction polyfit (avec Eigen)

#include <Eigen/Dense>
#include <vector>

std::vector<double> polyfit(const std::vector<double>& x,
                            const std::vector<double>& y,
                            int degree) {
    const int N = x.size();
    Eigen::MatrixXd A(N, degree + 1);
    Eigen::VectorXd Y(N);

    // Construction de la matrice de Vandermonde
    for (int i = 0; i < N; ++i) {
        double xi = 1.0;
        for (int j = degree; j >= 0; --j) {
            A(i, degree - j) = std::pow(x[i], j);
        }
        Y(i) = y[i];
    }

    // RÃ©solution par moindres carrÃ©s
    Eigen::VectorXd coeffs = A.colPivHouseholderQr().solve(Y);

    // Convertir en std::vector<double>
    return std::vector<double>(coeffs.data(), coeffs.data() + coeffs.size());
}

ðŸ§ª Exemple dâ€™utilisation :

#include <iostream>

int main() {
    std::vector<double> x = {1, 2, 3, 4, 5};
    std::vector<double> y = {1, 4, 9, 16, 25}; // f(x) = x^2 idÃ©alement

    int degree = 2;

    std::vector<double> coeffs = polyfit(x, y, degree);

    std::cout << "Coefficients (haut en bas, comme MATLAB):\n";
    for (double c : coeffs) {
        std::cout << c << " ";
    }
    std::cout << std::endl;

    return 0;
}

âœ… RÃ©sultat attendu (pour une parabole y = xÂ²) :

Coefficients (haut en bas, comme MATLAB):
1 0 0
