import numpy as np

# Lecture en little-endian natif
data_little = np.fromfile("fichier.dat", dtype='float32')

# Lecture en big-endian (correct si fichier = struct.pack('>f'))
data_big = np.fromfile("fichier.dat", dtype='>f4')

print("=== Little-endian ===")
print("Min:", data_little.min(), "Max:", data_little.max())
print("First 5:", data_little[:5])

print("\n=== Big-endian ===")
print("Min:", data_big.min(), "Max:", data_big.max())
print("First 5:", data_big[:5])

Observation	Ce que Ã§a veut dire
Min cassÃ© en float32 natif	Fichier nâ€™est pas little-endian
Min OK en '>f4'	Fichier est bien en big-endian
Max cassÃ© en '>f4'	Peut-Ãªtre que tu lis trop de valeurs (count)
Max OK en float32	Pur hasard â€” mauvaise lecture mais rÃ©sultat plausible

data = np.fromfile("fichier.dat", dtype='>f4', count=pixel_count)


Si jamais Ã§a ne marchepas : 

ðŸ”¥ Solution fiable (et souvent plus robuste) : utiliser np.frombuffer() aprÃ¨s lecture avec open
Voici un exemple bÃ©ton :

python
Copier
Modifier
with open("fichier.dat", "rb") as f:
    raw = f.read()  # lit tout le fichier binaire

data = np.frombuffer(raw, dtype='>f4')
âž¡ï¸ LÃ  tu es sÃ»r que :

tu maÃ®trises le buffer brut

NumPy lâ€™interprÃ¨te strictement selon ton dtype ('>f4')

aucun bug de fromfile (qui peut Ãªtre capricieux selon le systÃ¨me, le terminal, l'encodage, etc.)

