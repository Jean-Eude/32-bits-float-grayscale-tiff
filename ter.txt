// Génération asciiPlan étendu avec tabulations
std::ostringstream oss;
bool supported = true;

switch (nbCircles) {
    case 2:
        oss << "1\t2";
        break;
    case 3:
        oss << "\t1\t\n"
            << "2\t\t3";
        break;
    case 4:
        oss << "1\t\t2\n"
            << "\t3\t4";
        break;
    case 5:
        oss << "\t1\t\n"
            << "2\t\t3\n"
            << "4\t5";
        break;
    case 6:
        oss << "\t1\t\n"
            << "2\t\t3\n"
            << "4\t\t5\n"
            << "\t6";
        break;
    case 7:
        oss << "\t\t1\t\n"
            << "\t2\t\t3\n"
            << "4\t\t5\t6\n";
        break;
    case 8:
        oss << "\t1\t2\n"
            << "3\t\t4\n"
            << "5\t6\t7\n"
            << "\t\t8";
        break;
    case 9:
        oss << "1\t2\t3\n"
            << "4\t5\t6\n"
            << "7\t8\t9";
        break;
    case 10:
        oss << "1\t2\t3\t4\t5\n"
            << "6\t7\t8\t9\t10";
        break;
    case 12:
        oss << "1\t2\t3\t4\n"
            << "5\t6\t7\t8\n"
            << "9\t10\t11\t12";
        break;
    case 15:
        oss << "1\t2\t3\t4\t5\n"
            << "6\t7\t8\t9\t10\n"
            << "11\t12\t13\t14\t15";
        break;
    case 16:
        oss << "1\t2\t3\t4\n"
            << "5\t6\t7\t8\n"
            << "9\t10\t11\t12\n"
            << "13\t14\t15\t16";
        break;
    default:
        supported = false;
        break;
}

if (!supported) {
    std::cerr << "[INFO] Aucun plan ASCII défini pour " << nbCircles << " cercles.\n";
    return;
}

std::string asciiPlan = oss.str();

// Parsing du plan logique
std::map<int, std::pair<double, double>> logicalPositions;

std::istringstream iss(asciiPlan);
std::string line;
int row = 0, maxCol = 0;
while (std::getline(iss, line)) {
    std::istringstream lineStream(line);
    std::string token;
    int col = 0;
    while (std::getline(lineStream, token, '\t')) { // split par tabulation
        if (!token.empty() && std::isdigit(token[0])) {
            int id = std::stoi(token);
            logicalPositions[id] = {static_cast<double>(col), static_cast<double>(row)};
        }
        ++col;
    }
    maxCol = std::max(maxCol, col);
    ++row;
}
int maxRow = row;







struct Circle {
    double xc;
    double yc;
    double radius;
    int id = -1;
    std::string label;
    float intensity = 0.0f;
};

void processMaskAndFitCircles(const std::vector<std::vector<double>>& mask) {
    int height = mask.size();
    if (height == 0) return;
    int width = mask[0].size();

    std::vector<std::vector<int>> labels(height, std::vector<int>(width, 0));
    int current_label = 1;
    std::unordered_map<int, std::vector<std::pair<uint32_t, uint32_t>>> components;

    // Détection des composantes connexes
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (mask[y][x] > 0 && labels[y][x] == 0) {
                std::queue<std::pair<int, int>> q;
                q.push({x, y});
                labels[y][x] = current_label;

                while (!q.empty()) {
                    auto [cx, cy] = q.front(); q.pop();
                    components[current_label].emplace_back(cx, cy);

                    const int dx[] = {1, -1, 0, 0};
                    const int dy[] = {0, 0, 1, -1};

                    for (int dir = 0; dir < 4; ++dir) {
                        int nx = cx + dx[dir];
                        int ny = cy + dy[dir];
                        if (nx >= 0 && ny >= 0 && nx < width && ny < height &&
                            mask[ny][nx] > 0 && labels[ny][nx] == 0) {
                            labels[ny][nx] = current_label;
                            q.push({nx, ny});
                        }
                    }
                }
                ++current_label;
            }
        }
    }

    // Ajustement de cercle pour chaque composante
    std::vector<Circle> circles;
    for (const auto& [label, points] : components) {
        if (points.size() < 3) continue;

        Eigen::MatrixXd A(points.size(), 3);
        Eigen::VectorXd B(points.size());

        for (size_t i = 0; i < points.size(); ++i) {
            double x = static_cast<double>(points[i].first);
            double y = static_cast<double>(points[i].second);
            A(i, 0) = 2.0 * x;
            A(i, 1) = 2.0 * y;
            A(i, 2) = 1.0;
            B(i) = x * x + y * y;
        }

        Eigen::Vector3d sol = A.colPivHouseholderQr().solve(B);
        double xc = sol(0);
        double yc = sol(1);
        double c = sol(2);
        double radius = std::sqrt(xc * xc + yc * yc + c);
        circles.push_back({xc, yc, radius});
    }

    int nbCircles = static_cast<int>(circles.size());
    if (nbCircles < 2) {
        std::cerr << "[INFO] Pas assez de cercles détectés.\n";
        return;
    }

    // Plan logique ASCII
    std::ostringstream oss;
    bool supported = true;
    switch (nbCircles) {
        case 6:
            oss << "\t1\t\n"
                << "2\t\t3\n"
                << "4\t\t5\n"
                << "\t6\t";
            break;
        case 9:
            oss << "1\t2\t3\n"
                << "4\t5\t6\n"
                << "7\t8\t9";
            break;
        // ... ajouter plus de cas si nécessaire
        default:
            supported = false;
            break;
    }

    if (!supported) {
        std::cerr << "[INFO] Aucun plan ASCII défini pour " << nbCircles << " cercles.\n";
        return;
    }

    std::string asciiPlan = oss.str();

    // Parsing du plan logique
    std::map<int, std::pair<double, double>> logicalPositions;
    std::istringstream iss(asciiPlan);
    std::string line;
    int row = 0, maxCol = 0;
    while (std::getline(iss, line)) {
        std::istringstream lineStream(line);
        std::string token;
        int col = 0;
        while (std::getline(lineStream, token, '\t')) {
            if (!token.empty() && std::isdigit(token[0])) {
                int id = std::stoi(token);
                logicalPositions[id] = {static_cast<double>(col), static_cast<double>(row)};
            }
            ++col;
        }
        maxCol = std::max(maxCol, col);
        ++row;
    }
    int maxRow = row;

    // Normalisation des centres détectés
    double minX = std::numeric_limits<double>::max(), maxX = -minX;
    double minY = std::numeric_limits<double>::max(), maxY = -minY;
    for (const auto& c : circles) {
        minX = std::min(minX, c.xc);
        maxX = std::max(maxX, c.xc);
        minY = std::min(minY, c.yc);
        maxY = std::max(maxY, c.yc);
    }

    std::vector<std::pair<double, double>> normCenters;
    for (const auto& c : circles) {
        double nx = (c.xc - minX) / (maxX - minX + 1e-9);
        double ny = (c.yc - minY) / (maxY - minY + 1e-9);
        normCenters.emplace_back(nx, ny);
    }

    // Propriétés associées aux IDs
    std::map<int, std::pair<std::string, float>> circleProperties = {
        {1, {"A", 0.9f}}, {2, {"B", 0.8f}}, {3, {"C", 0.7f}},
        {4, {"D", 0.6f}}, {5, {"E", 0.5f}}, {6, {"F", 0.4f}},
        {7, {"G", 0.3f}}, {8, {"H", 0.2f}}, {9, {"I", 0.1f}},
    };

    // Appariement logique → cercles détectés
    std::vector<Circle> ordered(nbCircles);
    std::vector<bool> taken(nbCircles, false);
    for (const auto& [id, logicalPos] : logicalPositions) {
        double bestDist = std::numeric_limits<double>::max();
        int bestIndex = -1;
        double normX = logicalPos.first / static_cast<double>(maxCol);
        double normY = logicalPos.second / static_cast<double>(maxRow);
        for (int i = 0; i < nbCircles; ++i) {
            if (taken[i]) continue;
            double dx = normCenters[i].first - normX;
            double dy = normCenters[i].second - normY;
            double dist = dx * dx + dy * dy;
            if (dist < bestDist) {
                bestDist = dist;
                bestIndex = i;
            }
        }
        if (bestIndex >= 0) {
            Circle circle = circles[bestIndex];
            circle.id = id;
            if (circleProperties.count(id)) {
                circle.label = circleProperties[id].first;
                circle.intensity = circleProperties[id].second;
            }
            ordered[id - 1] = circle;
            taken[bestIndex] = true;
        }
    }

    // Affichage enrichi
    for (const auto& c : ordered) {
        std::cout << "Cercle #" << c.id
                  << " → Pos = (" << c.xc << ", " << c.yc << ")"
                  << ", Rayon = " << c.radius
                  << ", Label = " << c.label
                  << ", Intensité = " << c.intensity
                  << "\n";
    }
}



std::map<int, std::pair<std::string, float>> circleProperties;

if (nbCircles == 6) {
    circleProperties = {
        {1, {"A", 1.0f}},
        {2, {"B", 0.9f}},
        {3, {"C", 0.8f}},
        {4, {"D", 0.7f}},
        {5, {"E", 0.6f}},
        {6, {"F", 0.5f}},
    };
}
else if (nbCircles == 9) {
    circleProperties = {
        {1, {"A", 1.0f}},
        {2, {"B", 0.9f}},
        {3, {"C", 0.8f}},
        {4, {"D", 0.7f}},
        {5, {"E", 0.6f}},
        {6, {"F", 0.5f}},
        {7, {"G", 0.4f}},
        {8, {"H", 0.3f}},
        {9, {"I", 0.2f}},
    };
}
else {
    // Valeur par défaut si nbCircles inconnu
    for (int i = 1; i <= nbCircles; ++i) {
        std::string label = std::string(1, 'A' + ((i - 1) % 26));
        float intensity = 1.0f - (i - 1) / static_cast<float>(std::max(nbCircles - 1, 1));
        circleProperties[i] = {label, intensity};
    }
}




